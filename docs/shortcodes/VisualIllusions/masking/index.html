<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Masking # Intro and background # El visual masking es un fenómeno de percepción visual que ocurre cuando la visibilidad de una imagen, llamada objetivo, es reducida por la presencia de otra imagen que se superpone, llamada máscara.
Los patrones de Moiré son patrones de interferencia que aparecen cuando dos o más patrones de líneas se superponen y no están perfectamente alineados. Este efecto se produce cuando se colocan dos rejillas con patrones de líneas finas una encima de la otra, de tal manera que las líneas de una rejilla no están perfectamente alineadas con las líneas de la otra rejilla."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Masking # Intro and background # El visual masking es un fenómeno de percepción visual que ocurre cuando la visibilidad de una imagen, llamada objetivo, es reducida por la presencia de otra imagen que se superpone, llamada máscara.
Los patrones de Moiré son patrones de interferencia que aparecen cuando dos o más patrones de líneas se superponen y no están perfectamente alineados. Este efecto se produce cuando se colocan dos rejillas con patrones de líneas finas una encima de la otra, de tal manera que las líneas de una rejilla no están perfectamente alineadas con las líneas de la otra rejilla."><meta property="og:type" content="article"><meta property="og:url" content="https://visualcgroup.github.io/showcase/docs/shortcodes/VisualIllusions/masking/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-03-30T16:23:37-05:00"><title>Masking | Computación Visual</title><link rel=manifest href=/showcase/manifest.json><link rel=icon href=/showcase/favicon.png type=image/x-icon><link rel=stylesheet href=/showcase/book.min.a82d7e77ceb134d151c4d7e381eeb30623fbd5a524d58c584d8716ecec0205bd.css integrity="sha256-qC1+d86xNNFRxNfjge6zBiP71aUk1YxYTYcW7OwCBb0=" crossorigin=anonymous><script defer src=/showcase/flexsearch.min.js></script>
<script defer src=/showcase/en.search.min.3a8d658c77eb93c7f12a2b8af49a700131e474f288eefb605d9fa61576dbe5a7.js integrity="sha256-Oo1ljHfrk8fxKiuK9JpwATHkdPKI7vtgXZ+mFXbb5ac=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/showcase/><span>Computación Visual</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Shortcodes</span><ul><li><input type=checkbox id=section-d200ae8d5104b797f81d670a6f628a3f class=toggle checked>
<label for=section-d200ae8d5104b797f81d670a6f628a3f class="flex justify-between"><a href=/showcase/docs/shortcodes/VisualIllusions/>Visual Illusions</a></label><ul><li><a href=/showcase/docs/shortcodes/VisualIllusions/coloring/>Coloring</a></li><li><a href=/showcase/docs/shortcodes/VisualIllusions/machBands/>Mach Bands</a></li><li><a href=/showcase/docs/shortcodes/VisualIllusions/masking/ class=active>Masking</a></li><li><a href=/showcase/docs/shortcodes/VisualIllusions/depthPerception/>Depth Perception</a></li></ul></li></ul></li></ul><ul><li><a href=/showcase/Nosotros/>Nosotros</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/showcase/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Masking</strong>
<label for=toc-control><img src=/showcase/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#masking>Masking</a><ul><li><a href=#intro-and-background>Intro and background</a></li><li><a href=#code-and-results>Code and results</a><ul><li><a href=#moire-patterns>Moire Patterns</a></li><li><a href=#dithering>Dithering</a></li><li><a href=#image-kernel>Image kernel</a></li></ul></li><li><a href=#conclusions-and-future-work>Conclusions and future work</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=masking>Masking
<a class=anchor href=#masking>#</a></h1><h2 id=intro-and-background>Intro and background
<a class=anchor href=#intro-and-background>#</a></h2><p>El visual masking es un fenómeno de percepción visual que ocurre cuando la visibilidad de una imagen, llamada objetivo, es reducida por la presencia de otra imagen que se superpone, llamada máscara.</p><p>Los patrones de Moiré son patrones de interferencia que aparecen cuando dos o más patrones de líneas se superponen y no están perfectamente alineados. Este efecto se produce cuando se colocan dos rejillas con patrones de líneas finas una encima de la otra, de tal manera que las líneas de una rejilla no están perfectamente alineadas con las líneas de la otra rejilla. Como resultado, se produce una interferencia entre los patrones de líneas, lo que crea un patrón de ondulación o un efecto de malla en la imagen resultante.</p><h2 id=code-and-results>Code and results
<a class=anchor href=#code-and-results>#</a></h2><h3 id=moire-patterns>Moire Patterns
<a class=anchor href=#moire-patterns>#</a></h3><p>Para estos patrones se hizo uso de varias formas en grupos en donde se supeponen entre ellas para generar una nueva forma o patrón en el interior.</p><h4 id=patrón-de-círculos>Patrón de círculos
<a class=anchor href=#patr%c3%b3n-de-c%c3%adrculos>#</a></h4><p>En este caso se van a utilizar patrones con círculos para crear efectos ondulatorios al superponer dos series de círculos con el mismo espacio entre ellos, donde uno se mueve a lo largo del canvas mientras que el otro se mantiene estático. De esta manera se genera un patrón de moire.</p><details open><summary>relevantCode</summary><div class=markdown-inner><pre><code>    function setup() {
    createCanvas(400, 400);
    }

    function draw() {
    noFill();
    strokeWeight(ringWidth);
    for (let i = 0; i &lt; numRings; i++) {
        let radius = i * ringSpacing + ringWidth / 2;
        ellipse(width / 2, height / 2, radius * 2, radius * 2);
    }
    for (let i = 0; i &lt; numRings; i++) {
        let radius = i * ringSpacing + ringWidth / 2;
        ellipse(xVar, height / 2, radius * 2, radius * 2);
    }
    }
</code></pre></div></details><p>En este caso es posible modificar la velocidad a la que se mueve el segundo grupo de circulos dentro del canvas.</p><details><summary>Code</summary><div class=markdown-inner><pre><code>    let xVar = 200
    let numRings = 40;  // number of rings
    let ringSpacing = 5;  // spacing between rings
    let ringWidth = 2;  // width of each ring
    let ringColor = [255, 0, 0];  // color of rings
    let speedSlider;
    let speed = 0.5;
    let direction = true;

    function setup() {
    createCanvas(400, 400);
    speedSlider = createSlider(0, 10, 5, 1);
    speedSlider.position(10,10);
    speedSlider.style(&quot;width&quot;, &quot;80px&quot;);
    }

    function draw() {
    background(255);

    // draw rings
    noFill();
    strokeWeight(ringWidth);
    //stroke(ringColor);
    for (let i = 0; i &lt; numRings; i++) {
        let radius = i * ringSpacing + ringWidth / 2;
        ellipse(width / 2, height / 2, radius * 2, radius * 2);
    }
    for (let i = 0; i &lt; numRings; i++) {
        let radius = i * ringSpacing + ringWidth / 2;
        ellipse(xVar, height / 2, radius * 2, radius * 2);
    }
    maxRadius = numRings*ringSpacing + ringWidth / 2;
    if (direction){
        xVar += speedSlider.value()/10;
    }
    else {
        xVar -= speedSlider.value()/10;
    }
    if (xVar + maxRadius &gt; width + 50){
        direction = false
    }
    else if (xVar - maxRadius &lt; -50){
        direction = true
    }
    }
</code></pre></div></details><iframe id=moirePattern1 style=width:425px;height:425px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/moirePattern1.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h4 id=patrón-de-lineas-paralelas>Patrón de lineas paralelas
<a class=anchor href=#patr%c3%b3n-de-lineas-paralelas>#</a></h4><p>Dentro del siguiente código se tienen dos grupos de lineas paralelas, unas están fijas mientras que las otras van rotando desde el centro. Esto genera un efecto que crea la ilusión de generación de rombos de diferentes tamaños dependiendo del ángulo de giro del segundo grupo de lineas.</p><details open><summary>relevantCode</summary><div class=markdown-inner><pre><code>    function setup() {
        createCanvas(500, 500);
    }

    function draw() {
        background(255);
        for (let y = 0; y &lt; height; y += 10) {
            line(0, y, width, y);
        }
        push();
        translate(width/2, height/2); 
        rotate(angle);
        for (let y = -height; y &lt; height; y += 10) {
            line(-width/2, y, width/2, y);
        }
        pop();
    }
</code></pre></div></details><details><summary>Code</summary><div class=markdown-inner><pre><code>    let angle = 0;
    function setup() {
    createCanvas(500, 500);
    angleMode(DEGREES);
    strokeWeight(3);
    }

    function draw() {
    
    }
</code></pre></div></details><iframe id=moirePattern3 style=width:525px;height:525px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/moirePattern3.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h4 id=kinegrama>Kinegrama
<a class=anchor href=#kinegrama>#</a></h4><p>El siguiente kinegrama se genera a partir de una imágen preestablecida que se muestra dentro del mismo programa al hacer clic en el canvas de la misma. Sobre esta imagen, a forma de mascara, se coloca una capa de líneas que van de arriba a abajo y que revelan el contenido de la imagen de debajo, que sería el objetivo</p><details open><summary>relevantCode</summary><div class=markdown-inner><pre><code>    function preload() {
        img = loadImage(&quot;/showcase/sketches/assets/kinegram.png&quot;);
    }
    function setup() {
        createCanvas(400, 420);
    }
    function draw() {
        image(img,0,0);
        for(let i = -height/rectLen; i &lt; 0; i+=spacing){
            fill(&quot;black&quot;);
            rect(0,i*rectLen+y,width,rectLen);
        }
        y += rectSpeed;
        if ((-height+y) &gt;= height) {
            y = 0;
        }
    }
</code></pre></div></details><p>Esta imagen está hecha aparte y no se calcula dentro del programa, sin embargo es posible realiar un programa que calcule la imagen objetivo a partir de un gif o una serie de imagenes que se quieran visualizar de esta manera.</p><details><summary>Code</summary><div class=markdown-inner><pre><code>    let img;
    let rectSpeed = 0.5;
    let rectLen = 10;
    let spacing = 1.2;
    let y = 0;

    function preload() {
        img = loadImage(&quot;/showcase/sketches/assets/kinegram.png&quot;);
    }

    function setup() {
        createCanvas(400, 420);
    }

    function draw() {
        background(255);
        image(img,0,0);
        for(let i = -height/rectLen; i &lt; 0; i+=spacing){
            fill(&quot;black&quot;);
            rect(0,i*rectLen+y,width,rectLen);
        }
        y += rectSpeed;
        if ((-height+y) &gt;= height) {
            y = 0;
        }
        if(mouseIsPressed){
            background(255);
            image(img,0,0);
        }
    }
</code></pre></div></details><iframe id=kinegram style=width:425px;height:445px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/kinegram.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h3 id=dithering>Dithering
<a class=anchor href=#dithering>#</a></h3><iframe id=dithering style=width:625px;height:625px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/dithering.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h3 id=image-kernel>Image kernel
<a class=anchor href=#image-kernel>#</a></h3><p>En este caso se tiene un procesador de imágenes que soporta diferentes kernels de imágenes con su respectivo histograma y su cambio de brillo.
En este caso se puede subir cualquier imagen que se desee modificar y se mostrará esta imagen original al lado de la imagen modificada con los kernels que se escojan, además que el histograma se muestra siempre con la imagen modificada.
Se debe tener en cuenta que este histograma representa la cantidad de pixeles que tienen un mismo valor tonal, es decir la oscuridad o brillo, dentro de la imagen; es por esto que se genera un total de 256 líneas.</p><p>Cada uno de los diferentes kernels se pude escoger con el desplegable que se encuentra a la izquierda, mientras que se necesitan presionar las teclas &ldquo;+&rdquo; o &ldquo;-&rdquo; para cambiar el brillo de la imagen en cuestión.</p><iframe id=kernelImages style=width:625px;height:625px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/kernelImages.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h2 id=conclusions-and-future-work>Conclusions and future work
<a class=anchor href=#conclusions-and-future-work>#</a></h2><p>A partir del anterior trabajo se puede concluir que</p><ul><li><p>Los patrones de moire y los kinegramas son formas muy sencillas de hace ilusiones visuales al utilizar dos elementos en el que uno cubre al otro para general nuevas figuras a partir de lo que se quiere mostrar</p></li><li><p>Se pueden formar infinidad de patrones de moire con muchas figuras de diferentes formas y tamaños, sin embargo dentro de la más estudiadas se encuentran las formas más básicas como círculos o lineas</p></li><li><p>Un kinegrama tiene grandes aplicaciones en la realización de movimientos a partir de una imagen base, la cual puede ser calculada a partir de alguna serie de imagenes existentes.</p></li><li><p>El procesamiento de imagenes kernel es util cuando se requiere hacer un calculo más específico de algunas características que pueda tener la imagen en cuestión.</p></li></ul><p>Como trabajo futuro se espera poder implementar más patrones de moire mucho más complejos y que creen fiiguras más interesantes para el ojo humano. Además de generar la imágen objetivo de un kinegrama a partir de un gif o de varias imagenes en secuencia.</br>Por último se espera que dentro de los kernel de imagenes se pueda aplicar el mismo modelo a un video en tiempo real.</p><div class=book-expand><label><div class="book-expand-head flex justify-between"><span>Referencias</span>
<span>...</span></div><input type=checkbox class=hidden><div class="book-expand-content markdown-inner"><h2 id=referencias>Referencias
<a class=anchor href=#referencias>#</a></h2><ul><li><a href=https://en.wikipedia.org/wiki/Visual_masking>https://en.wikipedia.org/wiki/Visual_masking</a></li><li><a href=https://www.sciencedirect.com/topics/medicine-and-dentistry/visual-masking>https://www.sciencedirect.com/topics/medicine-and-dentistry/visual-masking</a></li><li><a href=https://www.britannica.com/science/moire-pattern>https://www.britannica.com/science/moire-pattern</a></li><li><a href=https://en.wikipedia.org/wiki/Kernel_%28image_processing%29>https://en.wikipedia.org/wiki/Kernel_(image_processing)</a></li><li><a href=https://setosa.io/ev/image-kernels/>https://setosa.io/ev/image-kernels/</a></li></ul></div></label></div><a href=/showcase/ class=book-btn>Get Home</a></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/VisualCGroup/showcase/commit/44d7f264d2d73cbf3b7a7232bf81017cd6a16fed title='Last modified by dzambranob | March 30, 2023' target=_blank rel=noopener><img src=/showcase/svg/calendar.svg class=book-icon alt=Calendar>
<span>March 30, 2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#masking>Masking</a><ul><li><a href=#intro-and-background>Intro and background</a></li><li><a href=#code-and-results>Code and results</a><ul><li><a href=#moire-patterns>Moire Patterns</a></li><li><a href=#dithering>Dithering</a></li><li><a href=#image-kernel>Image kernel</a></li></ul></li><li><a href=#conclusions-and-future-work>Conclusions and future work</a></li></ul></li></ul></nav></div></aside></main></body></html>